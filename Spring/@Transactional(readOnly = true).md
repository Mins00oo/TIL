## @Trancsactional(readOnly = true)

---
### `왜 사용하는 것일까 ?`
- 트랜잭션 범위는 유지하되, 조회 기능만 남겨두어
- 조회 속도가 개선된다
- 등록, 수정, 삭제 기능이 전혀 없는 서비스 메소드에서 사용하는 것을 추천
- 예상치 못한 엔티티의 등록, 변경, 삭제를 예방할 수 있다.

### `왜 그렇다면 조회 성능이 좋아지는걸까?`
- 엔티티가 영속성 컨텍스트에 관리되면 1차 캐시부터 변경 감지(dirty checking)까지 얻을 수 있는 혜택이 많다.
- But, 영속성 컨텍스트는 더 많은 메모리를 사용한다는 단점이 존재
- 따라서, 영속성 컨텍스트의 관리를 받지 않아, 성능적으로 더 나아진다

### `꼭 필요할까 ?`
- 개인적으로 써주는게 좋다라고 생각한다.
  1) 조회된 데이터를 retrun 한다해도 의도치 않게 데이터가 변경되는 일을 사전에 방지
  2) MySQL을 사용할 때 데이터가 날아가는것을 방지하기 위해 이중화 구성(master-slave)을 하는 경우가 있는데 
DB가 master와 slave로    
나누어져 있다면 readOnly=true로 있는 경우엔 읽기 전용으로 master가 아닌 slave를 호출한다.
따라서, DB서버의 부하를 줄이고 약간의 최적화를 할 수 있다.
  3) 코드를 접하는 사람들이 직관적으로 보기에 해당 메소드는 READ에 대한 동작만 수행할 것이라고 예상

