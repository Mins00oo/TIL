# 면접을 위한 CS 전공지식 노트
## [1장 디자인 패턴과 프로그래밍 패러다임](#1-디자인-패턴과-프로그래밍-패러다임)
- [1.1 디자인 패턴](#11-디자인-패턴)
  - [1.1.1 싱글톤 패턴](#111-싱글톤-패턴)
  - [1.1.2 팩토리 패턴](#112-팩토리-패턴)
  - [1.1.3 전략 패턴](#113-전략-패턴)
  - [1.1.4 옵저버 패턴](#114-옵저버-패턴)
  - [1.1.5 프록시 패턴](#115-프록시-패턴)
- [1.2 프로그래밍 패러다임]()

## [2장 네트워크]()
- [2.1 네트워크의 기초]()
- [2.2 TCP/IP 4계층 모델]()
- [2.3 네트워크 기기]()
- [2.4 IP 주소]()
- [2.5 HTTP]()



# 1. 디자인 패턴과 프로그래밍 패러다임

- 라이브러리
  - 공통으로 사용될 수 있는 특정한 기능들을 모듈화한 것을 의미한다.
  - 폴더명, 파일명 등에 대한 규칙이 없고 프레임워크에 비해 자유롭다.
  - 예를 들어, `도구`인 `가위`를 사용해 `내가`직접 컨트롤하여 자르는데, 이와 비슷하다.
- 프레임워크
  - 공통으로 사용될 수 있는 특정한 기능들을 모듈화한 것을 의미한다.
  - 폴더명, 파일명 등에 대한 규칙이 있으며 라이브러리에 비해 좀 더 엄격하다.
  - 예를 들어, 다른 곳으로 이동할 때 `도구`인 비행기를 타고 이동하지만 `비행기`가 컨트롤하고 난 가만히 있어야 한다.

## 1.1 디자인 패턴
프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 `규약` 형태로 만들어 놓은 것을 의미한다.

### 1.1.1 **싱글톤 패턴**
애플리케이션이 시작될 때, 어떤 클래스가 최초 한 번만 메모리를 할당하고 해당 메모리에 인스턴스를 만들어 사용하는 패턴
- 즉, 싱글톤 패턴은 하나의 인스턴스만 생성하여 사용하는 디자인 패턴
- 객체 vs 인스턴스
  - 객체: 붕어빵과 같은 예시로 볼 수 있다, 클래스의 인스턴스라고도 부른다.
  - 인스턴스: 객체 안에 포함되는 개념으로 볼 수 있으며 객체를 소프트웨어에 실체화한거다.
```
/* 클래스 */
public class Animal {
  ...
}
/* 객체와 인스턴스 */
public class Main {
  public static void main(String[] args) {
    Animal cat, dog; // '객체'

    // 인스턴스화
    cat = new Animal(); // cat은 Animal 클래스의 '인스턴스'(객체를 메모리에 할당)
    dog = new Animal(); // dog은 Animal 클래스의 '인스턴스'(객체를 메모리에 할당)
  }
}
https://gmlwjd9405.github.io/2018/09/17/class-object-instance.html
```
- 객체는 클래스의 타입으로 선언되었을 때 객체라고 부르고, 그 객체가 메모리에 할당되어서 실제 사용될 때 인스턴스라고 부른다

- 왜 쓰는가?
  1) 객체를 생성할 때마다 메모리 영역을 할당받아야 한다. 하지만 한번의 new를 통해 객체를 생성한다면 **메모리 낭비를 방지**할 수 있다.

  2) 싱글톤으로 구현한 인스턴스는 전역이므로, 다른 클래스의 인스턴스들이 **데이터를 공유하는 것이 가능한 장점**이 있다.

  3) 주로 데이터베이스에서 **커넥션풀**, **스레드풀**, **캐시**, **로그** 등의 상황에서 사용한다.

- 장점은?
  - 메모리 측면
    - 한 개의 인스턴스만을 고정 메모리 영역에 생성하고 추후 해당 객체에 접근할 때
    메모리 낭비를 방지할 수 있다.
  - 속도 측면
    - 생성된 인스턴스를 활용할 때는 이미 생성된 인스턴스를 활용하여 속도 측면에서
    이점이 있다.
  - 데이터 공유 측면
    - 전역으로 사용되기에 여러 클래스에서 데이터를 공유하며 사용할 수 있지만 동시성 문제가 발생할 수 있어 이 점은 유의해야 한다.
- 단점은?
  - SOLID원칙 중 OCP 원칙에 위배되는 상황이 있다.
    - 싱글톤 인스턴스가 혼자 너무 많은 일을 하거나, 많은 데이터를 공유시키면 다른 클래스간의 결합도가 높아지는데, 
이때 개방-폐쇄 원칙(OCP)에 위배된다.
    - 또한, 멀티 스레드 환경에서 **동기화 처리**를 하지 않았을 때, 인스턴스가 2개 생성되는
    문제도 발생할 수 있다.

  ```
  public class Singleton {
      // 단 1개만 존재해야 하는 객체의 인스턴스로 static 으로 선언
      private static Singleton instance;
  
      // private 생성자로 외부에서 객체 생성을 막아야 한다.
      private Singleton() {
      }
  
      // 외부에서는 getInstance() 로 instance 를 반환
      public static Singleton getInstance() {
          // instance 가 null 일 때만 생성
          if (instance == null) {
              instance = new Singleton();
          }
          return instance;
      }
  }
  ```

- getInstance()메서드가 처음 실행될 때만 하나의 인스턴스가 생성되고 그 후는 이미 생성된 인스턴스를 return하는 방식으로 진행
- 위에서 핵심은 private으로 된 기본 생성자이다. 생성자를 private으로 하여 외부에서 새로운 객체의 생성을 막아줘야 한다.
  ```
  // 같은 instance인지 Test
  public class Application {
      public static void main(String[] args) {
          Singleton singleton1 = Singleton.getInstance();
          Singleton singleton2 = Singleton.getInstance();
  
          System.out.println(singleton1);
          System.out.println(singleton2);
      }
  }
          /** Output
           * vendingmachine.Singleton@15db9742
           * vendingmachine.Singleton@15db9742
           **/
  ```
  
  [참고](https://velog.io/@seongwon97/%EC%8B%B1%EA%B8%80%ED%86%A4Singleton-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%9E%80)

### 1.1.2 **팩토리 패턴**
### 1.1.3 **전략 패턴**
### 1.1.4 **옵저버 패턴**
### 1.1.5 **프록시 패턴**
