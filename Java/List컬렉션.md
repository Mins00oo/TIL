# List 컬렉션

-----------------
### 배열의 한계점
- 배열에 저장할 수 있는 객체 수가 배열을 생성할 때 결정되기 때문에 불특정 다수의 객체를 저장하기 어려움
- 객체를 삭제했을 때 해당 인덱스가 비어버린다.
- 새로운 객체를 저장할 땐 어디 인덱스가 비어 있는지 확인해야한다.
-----------------
![image](https://user-images.githubusercontent.com/109537583/198156139-31fc2b17-824b-40fe-979b-85c82ad54c91.png)
- 객체를 인덱스로 관리하기 때문에 객체를 저장하면 자동 인덱스가 부여
- List 컬렉션은 객체 자체를 저장하는 것이 아니라 객체의 번지를 참조
- 동일한 객체를 중복 저장할 수 있는데, 이 경우 동일한 번지가 참조
- null도 저장이 가능한데, 이 경우 해당 인덱스는 객체를 참조 X
----------------
## ArrayList
`List 인터페이스의 구현 클래스`
- 배열은 생성할 때 크기가 고정이라 중간에 변경할 수 없음
- ArrayList는 저장 용량을 초과한 객체들이 들어오면 자동적으로 저장 용량이 늘어남
- 생성하기 위해서는 저장할 타입을 파라미터로 표기하고 기본 생성자를 호출, 처음부터 용량을 설정해 줄 수 있음
  - `List<String> list = new ArrayList<String>();`
  - `List<String> list = new ArrayList<String>(30);`
- 특정 객체를 삭제하면 바로 뒤 인덱스부터 마지막까지 앞으로 1씩 당겨짐
- 빈번한 객체 삭제와 삽입이 일어나는 곳에서는 사용하지 않는 것이 좋음
------------------
## Vector
`ArrayList와 동일한 내부 구조를 가짐`
- 생성하기 위해서는 젖아할 객체 타입을 타입 파라미터로 표기하고 기본 생성자를 호출
  - `List<E> list = new Vecotr();`
- 동기화된 메소드로 구성되어 있기 때문에 멀티 스레드가 동시에 이 메소드들을 실해할 수 없음
- 하나의 스레드가 실행을 완료해야만 다른 스레드를 실행할 수 있음
- 멀티 스레드 환경에서 안전하게 객체를 추가, 삭제할 수 있음
## LinkedList
`ArrayList와 사용 방법은 같지만 내부 구조가 완전히 다름`
![image](https://user-images.githubusercontent.com/109537583/198158814-03d676f2-fde3-434c-ad5e-af8ee29c83ef.png)
- 특정 인덱스의 객체를 제거하면 앞뒤 링크만 변경되고 나머지 링크는 변경되지 않음
- 객체를 삽입할 때도 마찬가지

![image](https://user-images.githubusercontent.com/109537583/198159101-e1088ec0-dc56-45ec-983e-ed3040d90218.png)
- 생성하기 위해서는 저장할 객체 타입을 파라미터 E에 표기하고 기본 생성자 호출
  - `List<E> list = new LinkedList<>(E);`
----------------------
## 성능차이 
![image](https://user-images.githubusercontent.com/109537583/198159531-71a74437-dd0b-4e40-a72d-5048d6181550.png)
- 조회시에는 ArrayList가 우위에 있음
- 중간에 삽입/삭제시에는 LinkedList가 우위에 있음
